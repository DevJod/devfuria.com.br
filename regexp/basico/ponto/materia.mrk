O ponto .
==========



O *ponto* casa com qualquer caracter inclusive com as quebras de linhas (\r e \n).

O ponto também casa com ele próprio.

<div class="code">
<h6>regexp</h6>
<pre>.</pre>
</div>

### Exemplo:
<div class="imagem">
    <img src="ponto-casa.png" alt="Exemplo de Expressão Regular" />
</div>
<br /><br /><br /><br />

### Exemplo do Marinho:
<div class="imagem">
    <img src="ponto-pag41-exemplos.png" alt="Exemplo de Expressão Regular" />
    <p>Fonte:
        <a href="http://www.piazinho.com.br/ed3/exemplos.html#1">Livro: Expressões Regulares 3 edição, pag 41#1</a>
    </p>
</div>

### Palavras que foram ou não acentudas:
<div class="imagem">
    <img src="ponto-pag41-acentos.png" alt="Exemplo de Expressão Regular" />
    <p>Fonte:
        <a href="http://www.piazinho.com.br/ed3/exemplos.html#2">Livro: Expressões Regulares 3 edição, pag 41#2</a>
    </p>
</div>


### Palavras que começam com maiúsculas ou não:

<div class="imagem">
    <img src="ponto-pag41-maiuscula.png" alt="Exemplo de Expressão Regular" />
    <p>Fonte:
        <a href="http://www.piazinho.com.br/ed3/exemplos.html#3">Livro: Expressões Regulares 3 edição, pag 41#3</a>
    </p>
</div>


### Palavras com grafia possivelmente errada:

<div class="imagem">
    <img src="ponto-pag41-grafia.png" alt="Exemplo de Expressão Regular" />
    <p>Fonte:
        <a href="http://www.piazinho.com.br/ed3/exemplos.html#4">Livro: Expressões Regulares 3 edição, pag 41#4</a>
    </p>
</div>


### Palavras que parcem-se com horas:
<div class="imagem">
    <img src="ponto-pag42-horas.png" alt="Exemplo de Expressão Regular" />
    <p>Fonte:
        <a href="http://www.piazinho.com.br/ed3/exemplos.html#5">Livro: Expressões Regulares 3 edição, pag 42#5</a>
    </p>
</div>

### Tags de HTML:
<div class="imagem">
    <img src="ponto-pag42-tags.png" alt="Exemplo de Expressão Regular" />
    <p>Fonte:
        <a href="http://www.piazinho.com.br/ed3/exemplos.html#6">Livro: Expressões Regulares 3 edição, pag 42#6</a>
    </p>
</div>


### PHP - preg\_match()

Segundo o Marinho, as funções PCRE são mais rápidas que as POSIX e para funcionarem o PHP deverá ser compilado com 
suporte a bilioteca PCRE.

No primeiro exemplo utilizo a função *preg_match()*, ela aceita 5 parâmetros. Por enquanto os três primeiros nos basta.

* O primeiro parâmetro é a expressão regular.

* O segundo parâmetro é a string onde pesquisaremos a expressão.

* O terceiro parâmetro é um array que armazenará os resultados (partes) da string original

<div class="code">
<h6>PHP</h6>
<pre>&lt;?php
$subject   = "casa, castanha, carpinteiro, cana de açucar, cama, casar, cavalo.";
$pattern   = "/ca.a/";
$retorno = array();

# Executa nossa expressão
<em>$resultado = preg_match($pattern, $subject, $retorno);</em>

if ($resultado === 1) {
    
    print "casou";
    var_dump($retorno);
    
} else if ($resultado === 0) {
    
    print "não casou";
    var_dump($retorno);
    
} elseif ($resultado === false) {
    
    print "ocorreu um erro";
    
}
?&gt;</pre>
</div>



Repare que além da variável colocada como terceiro parâmetro ($retorno) observamos também a variével *$retorno*. 

A função retorna um valor para sabermos se obtivemos sucesso ou não e, no caso do sucesso, podemos saber quais as partes
que casaram.

Para isso, basta utilizar o terceiro parâmetro, ele será um array com as partes no caso de sucesso, ou será um array vazio
no caso de insucesso (não casou).

Repare também que eu testo a variável *$resultado* de 3 maneiras: 

    se o valor é igual a 1 então
        print "casou"
    se o valor é igual a 0 então
        print "não casou"
    se o valor é igual a false então
        print "ocorreu um erro"




### PHP - preg\_match\_all()

No exemplo anterior, o resultado retornado pela função preg_math() foi o primeiro valor que casou no caso a sttring "casa",
veja a figura abaixo:

<div class="imagem">
    <img src="php-preg-math.png" alt="Resultado do primeiro exemplo em PHP" />
</div>


Mas, se observarmos o exemplo lá no começo da matéria, a expressão casa com outras partes da string:

    "casa, cana, cama, casa, cava"

Como fazer para obter esse resultados?

Uma saída é utilizar a função *preg\_math\_all()*, ela carregará a varirável *$retorno* com todos os resultados possíveis,
veja a figura abaixo:

<div class="imagem">
    <img src="php-preg-math-all.png" alt="Resultado do primeiro exemplo em PHP" />
</div>

Segue o cóodigo alterado para a função preg\_math\_all():

<div class="code">
<h6>PHP</h6>
<pre>&lt;?php
$subject   = "casa, castanha, carpinteiro, cana de açucar, cama, casar, cavalo.";
$pattern   = "/ca.a/";
$retorno = array();

# Executa nossa expressão
<em>$resultado = preg_match_all($pattern, $subject, $retorno);</em>

if ($resultado >= 1) {
    
    print "casou";
    var_dump($retorno);
    
} else if ($resultado === 0) {
    
    print "não casou";
    var_dump($retorno);
    
} elseif ($resultado === false) {
    
    print "ocorreu um erro";
    
}
?&gt;</pre>
</div>

Obsever que eu também alterei o "primeiro if" de:

    if ($resultado === 1) {

para:

    if ($resultado >= 1) {

Isso se deve ao fato de que a função preg\_math\_all() retorna um número inteiro com a quantidade de ocorrências
encontradas, no exemplo o valor da variável *$resultado* =e igual a 5 (pois temos cinco resultados).

Para saber mais, inclusive sobre os demais parâmetros não comentados, veja a documentação oficial:

[http://www.php.net/manual/pt_BR/function.preg-match.php](http://www.php.net/manual/pt_BR/function.preg-match.php)



### JS - string.match()

Em JS temos a forma *string.match()* onde "string" é a variável contendo a sua string e "match()" é a função que evocamos
para executar a ER.

<div class="code">
<h6>JS forma1-string-match.js</h6>
<pre>
var string = "casa, castanha, carpinteiro, cana de açucar, cama, casar, cavalo.",
    pattern = /ca.a/,
    resultado;

// Executa nossa expressão
resultado = string.match(pattern);

if (resultado) {
    console.log("casou", resultado);
} else {
    console.log("não casou", resultado);
}
</pre>
</div>

Se a ER casar com a string então a variável *resultado* conterá um array com a parte que casou, mas apenas a primeira
ocorrência.

Se você precisar das demais ocorrências terá que fazer uma pequena alteração na ER, veja:

    pattern = /ca.a/g,

Tivemos que incluir a opção "g" de "global", veja mais na
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FString%2Fmatch">documentação oficial</a>.




### JS - pattern.test()

Abaixo temos a forma mais usual em JS, ou pelo menos é a mais comentada.

Diferentemente da primeira função (string.match), o valor da variável *resultado* será true ou false e a opção global
"g" não funcionou, sou seja, não descobri uma forma de olhar as demais ocorrência, apenas a primeira.

<div class="code">
<h6>JS forma2-patter-test.js</h6>
<pre>
var string = "casa, castanha, carpinteiro, cana de açucar, cama, casar, cavalo.",
    pattern = /ca.a/,
    resultado;

// Executa nossa expressão
resultado = pattern.test(string);

if (resultado) {
    console.log("casou", resultado);
} else {
    console.log("não casou", resultado);
}
</pre>
</div>

Uma forma variante porém semelhante é a encontrada abaixo:

<div class="code">
<h6>JS forma3-patter-test.js</h6>
<pre>
var string = "casa, castanha, carpinteiro, cana de açucar, cama, casar, cavalo.",
    pattern,
    resultado;

// Executa nossa expressão
<em>pattern = new RegExp("ca.a");</em>
resultado = pattern.test(string);

if (resultado) {
    console.log("casou", resultado);
} else {
    console.log("não casou", resultado);
}
</pre>
</div>

O atrativo dessa variante é que a ER criada apartir de uma string lhe dá mair poder de flaxibilidade e, obviamente, 
maior responsabilidade.

Lembre-se do conselho do tio do homen-aranha: "quanto maior o poder, maior a responsabilidade"



### JS - pattern.exec()

Essa também é uma forma bastante utilizada, principalmente pelo fato dela trazer todas as ocorrências.

Repare apenas que a opção global "g" teve que ser utilizada, sem ela o navegador (FireFox 19) entra em um loop infinito.

<div class="code">
<h6>JS forma3-patter-test.js</h6>
<pre>
var string = "casa, castanha, carpinteiro, cana de açucar, cama, casar, cavalo.",
    pattern = /ca.a/g,
    resultado;

// Executa nossa expressão
var i = 0;
while(resultado = pattern.exec(string)){
    console.log("casou", resultado);
}
</pre>
</div>